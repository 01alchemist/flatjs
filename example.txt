// This assumes a few things that don't exist:
//
//   SELF method calls
//   Macro expansion of SELF.prop = expr and SELF.prop += expr
//    (and note the chained one in init)

@flatjs class IntQueueRepr
{
    spaceAvailable: synchronic int32
    dataAvailable: synchronic int32

    lock: synchronic int32
    head: int32
    tail: int32
    used: int32
    queue: array(int32)
    length: int32;

    @init(self, length) {
	SELF.length = length;
	SELF.lock = 0;
	SELF.used = SELF.head = SELF.tail = 0;
	SELF.queue = @new array(int32, length);
	return self
    }

    // None of these are virtual and we should not pay for vcall overhead.
    // But can that be optimized out (under what assumptions?) or should
    // there be annotations?

    @method enqueue(self, ints, timeout) {
	var required = ints.length + 1;

	if (!SELF.acquireWithSpaceAvailable(required, t))
	    return false;

	var q = SELF.queue;
	var qlen = SELF.length;
	var tail = SELF.tail;
	int32.array_set(q, tail, ints.length);
	tail = (tail + 1) % qlen;
	for ( var i=0 ; i < ints.length ; i++ ) {
	    int32.array_set(q, tail, ints[i]);
	    tail = (tail + 1) % qlen;
	}
	SELF.tail = tail;
	SELF.used += required;

	SELF.releaseWithDataAvailable();
	return true;
    }

    @method acquireWithSpaceAvailable(self required, t) {
	var limit = typeof t != "undefined" ? Date.now() + t : Number.POSITIVE_INFINITY;
	for (;;) {
	    SELF.acquire();
	    var length = SELF.length;
	    if (length - SELF.used >= required)
		return true;
	    var probe = SELF.spaceAvailable;
	    SELF.release();
	    if (required > length)
		throw new Error("Queue will never accept " + required + " words");
	    var remaining = limit - Date.now();
	    if (remaining <= 0)
		return false;
	    SELF.expectUpdate_spaceAvailable(probe, remaining);
	}
    }

    @method acquire(self) {
	while (SELF.compareExchange_lock(0, 1) != 0)
	    SELF.expectUpdate_lock(1, Number.POSITIVE_INFINITY);
    }

    @method release(self) {
	SELF.lock = 0;
    }

} @end

function IntQueue(length) {
    this._repr = IntQueueRepr.init(@new IntQueue, length);
}

IntQueue.prototype.enqueue = function(ints, t) { return IntQueueRepr.enqueue(this._repr, ints, t) }
IntQueue.prototype.dequeue = function(t) { return IntQueueRepr.dequeue(this._repr, t) }

// End

These struct definitions:

  @shared struct Point {
    x: float64
    y: float64

    @get(self) { return { x: SELF_x, y: SELF_y } }
  } @end

  @shared struct Sphere {
    r: float64
    c: Point
  } @end

  @shared struct Spheres {
    a: Sphere
    b: Sphere
    m: atomic int32
  } @end

turn into these definitions:

  const Point = {
      SIZE:8,
      ALIGN:8,

      x: function(self) { return _mem_i32[(self+0)>>2] },
      y: function(self) { return _mem_i32[(self+4)>>2] },

      set_x: function(self, v) { _mem_i32[(self+0)>>2] = v; },
      set_y: function(self, v) { _mem_i32[(self+4)>>2] = v; },

      _get: function (self) { x: Point.x(self), y: Point.y(self) } }
  };

  const Sphere = {
      SIZE: 16,
      ALIGN: 8,

      c: function (self) { Point._get(self+8) }

      c_x: function (self) { return _mem_i32[(self+8)>>2]; },
      c_y: function (self) { return _mem_i32[(self+12)>>2]; },
      r: function (self) { return _mem_f64[(self+8)>>3]; },

      set_c_x: function (self, v) { _mem_i32[(self+8)>>2] = v; },
      set_c_y: function (self, v) { _mem_i32[(self+12)>>2] = v; },
      set_r: function(self, v) { _mem_f64[(self+8)>>3] = v; },

      ref_c: function(self) { return self+8 }
  };

  const Spheres = {
      SIZE = 40,
      ALIGN = 8,

      ref_a: function(self) { return self },
      ref_b: function(self) { return self+16 },

      a_c: function (self) { Point._get(self+8) }
      b_c: function (self) { Point._get(self+24) }

      ref_a_c: function (self) { return self+8 },
      ref_b_c: function (self) { return self+24 }.

      ... etc, lots of methods

      m: function(self) { return Atomics.load(_mem_i32, (self+32)>>2) }
      set_m: function(self, v) { Atomics.store(_mem_i32, (self+32)>>2, v) }
      add_m: function(self, v) { return Atomics.add(_mem_i32, (self+32)>>2, v) }
      ...
      compareExchange_m: function(p, o, n) { return Atomics.compareExchange(_mem_i32, (self+32)>>2, o, n) }
  };



----------------------------------------------------------------------

Example:

  @shared struct Vec3 {
    x: float64
    y: float64
    z: float64
  } @end

  @shared struct Material {
    diffuse:   Vec3
    specular:  Vec3
    shininess: float64
    ambient:   Vec3
    mirror:    float64
  } @end
  
  @shared class Surface {
    m:Material

    @method intersect(self, a, b, c, d) { throw "Pure" }
    @method normal(self) { throw "Pure" }
  } @end
  
  @shared class Sphere extends Surface {
    center: Vec3
    radius: float64

    @method intersect(self, a, b, c, d) { ... }
    @method normal(self) { ... }
  } @end

  @shared class Triangle extends Surface {
    v1: Vec3
    v2: Vec3
    v3: Vec3

    @method intersect(self, a, b, c, d) { ... }
    @method normal(self) { ... }
  } @end

  @shared class Scene extends Surface {
    objs: array(Surface)

    @method intersect(self, a, b, c, d) { ... }
    @method normal(self) { ... }
  } @end

