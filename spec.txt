# Parlang

23 May 2015 / lhansen@mozilla.com

## Introduction

Parlang is a simple language that is currently layered on, but can
eventually be embedded in, Javascript.

The purpose of Parlang is to allow JS programs to use shared memory
somewhat conveniently and with high performance by layering structured
types onto shared memory.

Reference types (classes with single inheritance, and arrays) and
value types (structures) are supported, with named and typed fields
and some simple method facilities.  Methods on classes are virtual.
Macros sweeten the syntax further.

Objects in shared memory are represented in JS by their pointer
values, ie, as integer byte offsets into a single shared heap.  That
is a weak representation, but it is (much) more performant than
allocating and managing front objects, and right now performance is
the main focus of this exercise.

Also for performance reasons the language is fairly static and is
implemented by means of a rewriter that performs extensive in-line
expansion.  There are few dynamic features beyond virtual methods on
shared-class instances.  All memory management is manual, a la C++.
All fields in shared memory are statically typed.

For ease of processing *only*, the syntax is currently line-oriented:
Line breaks are explicit in the grammars below and some "@" characters
appear here and there to make recognition easier.  Please don't get
hung up on this, it's just a matter of programming to fix it but this
is not my focus right now.

The following is the bare specification.  See example.txt for worked
examples, and demo/ for larger examples.  See a later section, TODO,
for a run-down of missing but desirable features.


## Struct types

A struct describes a value type (instances do not have object
identity) with named, mutable fields.

### Syntax

```
  Struct-def ::= (lookbehind EOL)
                 "@shared" "struct" Id "{" Comment? EOL
                 ((Comment | Field) EOL)*
                 ((Comment | Struct-Method) EOL)*
		 "}" "@end" Comment? EOL

  Field ::= Ident ":" Type ";"? Comment? EOL

  Comment ::= "//" Not-EOL*

  Type ::= AtomicType | ValType
  AtomicType ::= ("atomic" | "synchronic")? ("int8" | "uint8" | "int16" | "uint16" | "int32" | "uint32")
  ValType ::= ("int8" | "uint8" | "int16" | "uint16" | "int32" | "uint32")
            | "float32"
	    | "float64"
            | Id
            | array(ValType)

  Struct-Method ::= "@get" "(" "self" ")" Function-body
                  | "@set" "(" "self" ("," Parameter)* ("," "..." Id)? ")" Function-body
                  | "@copy" "(" "self", Parameter ")" Function-body

  Parameter ::= Id (":" Tokens-except-comma-or-rightparen )?
```

NOTE: The annotation on the Parameter is not used by Parlang, but is
allowed in order to interoperate with TypeScript.

NOTE: The restriction of properties before methods is a matter of
economizing on the markup; as it is, properties don't need eg "@var"
before them.


### Static semantics

There is a program-wide namespace for shared types; the Id naming
the struct must be unique within that namespace.

A named field type must be defined somewhere in the set of translation
units that are processed together.

The struct type must not reference itself directly or indirectly via a
chain of struct-typed fields.

Every field name must be unique within the struct.

Within the bodies of @get, @set, and @copy, 'this' has an undetermined
binding (for now) and should not be referenced.  [That will be nailed
down and will either be the global object, or the object representing
the type being defined.]


### Translation

For a struct type named R, with field names F1 .. Fn, the following
will be defined, where "self" denotes an address of memory that can
hold an instance of R.


#### Global value properties

R is a global "var" holding an object designating the type.  [More
ideally a const with non-configurable properties.]

R.SIZE is the size in bytes of R, rounded up such that an array of R
structures can be traversed by adding R.SIZE to a pointer to one
element of the array to get to the next element, and allocating
n*R.SIZE will allocate space enough to hold n such elements.

R.ALIGN is the required alignment for R, in bytes.


#### Global function properties

If a field Fk does not have struct type then the following functions
are defined:

* R.Fk(self) => value of self.Fk field
* R.set_Fk(self, v) => void; set value of self.Fk field to v

If a field Fk does not have struct type and is designated "atomic" then
the getter and setter just shown use atomic loads and stores.  In
addition, the following atomic functions are defined:
  
* R.compareExchange_Fk(self, o, n) => if the value of self.Fk field is o then store n; return old value
* R.add_Fk(self, v) => add v to value of self.Fk field; return old value
* R.sub_Fk(self, v) => subtract v from value of self.Fk field; return old value
* R.and_Fk(self, v) => and v into value of self.Fk field; return old value
* R.or_Fk(self, v) => or v into value of self.Fk field; return old value
* R.xor_Fk(self, v) => xor v to value of self.Fk field; return old value

If a field Fk does not have struct type and is designated "synchronic"
then the setter and atomics just shown are synchronic-aware (every
update performs a notification).  In addition, the following
synchronic functions are defined:

* R.expectUpdate_Fk(self, v, t) => void; wait until the value of the self.Fk field is observed not to hold v, or until t milliseconds have passed
* R.loadWhenEqual_Fk(self, v) => wait until the value of the self.Fk field is observed to hold v, then return the value of that field (which might have changed since it was observed to hold v)
* R.loadWhenNotEqual_Fk(self, v) => wait until the value of the self.Fk field is observed not to hold v, then return the value of that field (which might have changed back to v since it was observed)
* R.notify_Fk(self) => wake all waiters on self.Fk, making them re-check their conditions.

If a field Fk has a struct type T with fields G1 .. Gm then the
following functions are defined:

* R.Fk(self) => if T does not have a @get method then this is undefined. Otherwise, a function that invokes the @get method on a reference to self.Fk.
* R.set_Fk(self, ...args) => if T does not have a @set method then this is undefined.  Otherwise, a function that invokes the @set method on a reference to self.Fk and ...args
* R.ref_Fk(self) => A reference to self.FK.

Getters, setters, and accessors for fields G1 through Gm within Fk,
with the general pattern R.Fk_Gi(self) and R.Fk_op_Gi(self,...), by
the rules above.


## Class types.

A class describes a reference type with mutable fields.

It takes the form of a number of fields followed by a number of
methods.  As for structs, if a field type is a struct type then the
fields of that struct will appear as subfields of the class being
defined.  If a field type is a class type then the value of the field
is a class instance address.

### Syntax

```
  Class-def ::= (lookbehind EOL)
                "@shared" "class" Id ("extends" Id)? "{" Comment? EOL
                ((Comment | Field | Class-Method) EOL)*
		"}" "@end" Comment? EOL

  Class-method ::= "@method" Id "(" "self" ("," Parameter)* ("," "..." Id)? ")" Function-body
```

### Static semantics

No cycles in the inheritance graph.

Uniqueness as for structs (classes and structs share the same
namespace).
  
Base types may be forward declared.


### Dynamic semantics

Before memory for a class instance can be used as a class instance,
the class's initInstance method must be invoked on the memory.


### Translation

The first field of an object is a hidden int32 field that holds a
globally invariant type identifier, see below.

The fields of a supertype are prepended to the fields of the
subtype, for purposes of layout.
  
O_SIZE as for structs.

O_ALIGN as for structs.

O_ID for the type ID for the type.

Field getters/setters are translated as for structs.
  
A method "meth" for object type O with subtypes J and K where J
overrides meth but K does not (and in this case J could be a subtype
of K, or not), turns into this global function:

```
    function O_meth(self, arg, ...) {
        switch (_mem_i32[self>>2]) {
	case J_ID: return J_meth_impl(self, arg, ...); 
	default:   return O_meth_impl(self, arg, ...);
	}
    }
```

where the arguments keep their annotations, the annotations on
O_meth are those of the method defined on O, the others may differ.

NOTE: _impl method and how to invoke on super


## Array types

Parlang arrays are primitive reference types that do /not/ carry their
length: they are simply a sequence of elements of a given type within
memory.

Allocating an array of type T of length n requires only allocating
memory for n*T.SIZE.  (For primitive types T, use Parlang.T.SIZE
instead, see below.)

* R.array_get(ptr, i)  => Read the ith element of an array of R whose base address is ptr.  Not bounds checked.  If the base type of the array is a structure type this will only work if the type has a @get method.
* R.array_set(ptr, i, v) => Set ditto / @set

Note these complications, as for T.SIZE: The syntax is really clunky.
Maybe we want macros T_array_get and T_array_set for primitive types
T.

    // For debugging only
    @method ref(self, y, x) {
	return Parlang.int32.array_get(SELF_data, (SELF_height-y)*SELF_width+x);
    }

    // Not a hot function
    @method setColor(self, y, x, v) {
	Parlang.int32.array_set(SELF_data, (SELF_height-y)*SELF_width+x] = (255<<24)|((255*v.z)<<16)|((255*v.y)<<8)|(255*v.x);
    }


## @new macro

An instance of the class type may be allocated and initialized with
the operator-like @new macro.  Specifically, @new T for shared class
type T expands into this:

  T.initInstance(Parlang.alloc(T.SIZE, T.ALIGN))

ALSO: @new array(T)


## SELF accessor macros

Inside the method for a struct or class R with a suite of accessor
methods M1..Mn, there will be defined non-hygienic macros
SELF_M1..SELF_Mk.  A reference to SELF_Mj(arg,...) is rewritten
as a reference to R.Mj(self, arg, ...).

In the special case of a field getter Mg, which takes only the self
argument, the form of the macro invocation shall be SELF_Mg, that
is, without the empty parameter list.


## Pervasive accessor macros and KEEP directives

By default, every function property on a type R is expanded in-line
at the point of reference, and the function is not actually
available as a function at run-time.

To retain a function property as a function and to disable its
inline expansion, use an @keep directive somewhere within the
source file:

```
    Keep ::= (lookbehind EOL) "@keep" Pattern ("," Pattern)* ";"? Comment? EOL

    Pattern ::= Id
```

This is a hack, really - later I want to experiment with the
performance implications of just keeping everything, and indeed, of
not expanding anything in-line.


## Environment

There is a new global object called "Parlang".  This is defined in
parlang.js, which must be loaded before the application files.

For each primitive type (int8, uint8, int16, uint16, int32, uint32,
float32, float64) there is a property on the Parlang object with the
type name containing the following properties:

* SIZE is the size in bytes of the type
* ALIGN is the required alignment in bytes of the type

The Parlang object has the following methods:

* init(sab [, initialize]) takes a SharedArrayBuffer and installs it as the global heap.  If initialize=true then the shared memory is also appropriately initialized.  initialize must be true in the first call to init() the call that performs initialization must return before any other calls to init() are made.  [Normally this means you init(...,true) on the main thread before you send sab to the workers.]
* alloc(numBytes, byteAlignment) allocates an object of size numBytes with alignment at least byteAlignment and returns it.  If the allocation fails then an exception is thrown.  This never returns 0.
* calloc(numBytes, byteAlignment) is like alloc, but zero-initializes the memory.
* free(p) frees an object p that was obtained from alloc(), or does nothing if p is 0.

The allocator operates on the shared memory and is thread-safe.


## How to run the translator

The translator has to be run on all files in the application
simultaneously, and will resolve all types in all files.  It would
normally output a file for each input file.


## Type IDs

Type IDs must be unique and invariant across workers, which are all
running different programs.

A type ID could be the hash value of a string representing the name
and structure of a type.

If a program has two types with the same type ID then the program
cannot be translated.  A fix is likely to change the name of one of
the conflicting types.  If this turns out to be a constant problem we
can introduce a notion of a "brand" on a type which is just a fudge
factor to make the type IDs work out.  (This scales poorly but is
probably OK in practice.)

Eg, O>Triangle>Surface>> is a unique identifier but does not help us
catch errors easily.


## Rationale

Struct types and class types are separate because class types need
different initialization (vtable, chiefly).  By keeping these
separate, it becomes sensible to always give a class type a vtable and
never pay for that in a struct.


## TODO

These are ideas it would be nice to support:

* No particularly good reason why struct types can't inherit
* No particularly good reason why struct types can't have non-virtual methods
* SIMD primitive types
* In-line fixed-length array types
* String types
* Instead of T.ref_fld(self) we could operate with T.offset_fld as a constant, if it matters
