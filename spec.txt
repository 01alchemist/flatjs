This is a simple language that is embedded in Javascript and allows JS
programs to use shared memory somewhat conveniently.

For ease of processing, the syntax is line-oriented: Line breaks are
explicit in the grammar below.

TODO: I really think it will be useful to at least have setters for
      entire records, that grab values out of JS objects.  But in
      practice even getters, to extract entire records, will likely be
      desirable.  We could have annotations to enable this, eg,
      "ENABLE GETTER SETTER", it might remove an error source where
      _REF was intended but forgotten.

      The thing is, for a field it is the context that determines this.
      So:

         m: Material getter setter

TODO: For records, R_INIT is useful in the same way a setter is, it
      should take an object that responds to accessors.

TODO: For objects, there has to be a pre-initializer (to set up metadata),
      so call this R_NEW.  Then R_INIT can exist too.

MAYBE:  OPTION INIT

Structs. 

A struct describes a value type.  It takes the form of a number of
fields.  If a field type is a struct type then the fields of that
struct will appear as subfields of the struct being defined.  If a
field type is an object then the value of the field is the object's
address.

Syntax:

  Struct-def ::= (lookbehind EOL)
                 "@shared" "struct" Id "{" Comment? EOL
                 ((Comment | Field) EOL)*
		 "}" "@end" Comment? EOL

  Field ::= Ident ":" Type ";"? Comment? EOL

  Comment ::= "//" Not-EOL*

  Type ::= ("atomic" | "synchronic")? ("int8" | "uint8" | "int16" | "uint16" | "int32" | "uint32")
         | "float32"
	 | "float64"
	 | Id ("getter" | "setter")*

  (TODO: SIMD types)

Static semantics:

  The Id naming the record must define a type that is globally unique.

  The field names must be unique within the record.

  The record type must not be circular.  (This means: If a field that
  has a Type that is an Id X then: X must not be the Id naming the
  record; if X denotes a record type, then no field of the type X must
  reference the Id naming the record; recursively)

  Options are allowed only if the type name designates a record type.

  == optimization, do later ==
  The function definitions for field access generated by the
  translation (see below) are considered as reserved word outside of
  any definition and the translator may subsitute the body of a
  function for a reference to the function.

  Generated functions that are only observed in call contexts may be
  elided from the translation altogether.
  == end ==

Translation:

  For a record type named R, with field names F1 .. Fn, the following
  will be defined, where self denotes an address of memory that can
  hold R.

  Global value properties:

    R_SIZE => size in bytes of R, rounded up such that an array of R
              structures can be traversed by adding R_SIZE to a pointer
	      to one element of the array to get to the next element,
	      and allocating n*R_SIZE will allocate space enough to
	      hold n such elements with appropriate alignment.

    R_ALIGN => alignment for R, in bytes

  Global functions:
  
  If a field Fk does not have record type then the following function
  is defined:

    R_Fk(self) => value of self.Fk field
    R_set_Fk(self, v) => void; set value of self.Fk field to v

  If a field Fk is designated atomic then the getter and setter just
  shown use atomic loads and stores.  In addition, the following
  atomic functions are defined:
  
    R_compareExchange_Fk(self, o, n) => if the value of self.Fk field is o then store n; return old value
    R_add_Fk(self, v) => add v to value of self.Fk field; return old value
    R_sub_Fk(self, v) => add v to value of self.Fk field; return old value
    R_and_Fk(self, v) => add v to value of self.Fk field; return old value
    R_or_Fk(self, v) => add v to value of self.Fk field; return old value
    R_xor_Fk(self, v) => add v to value of self.Fk field; return old value

  If a field Fk has a record type T with fields G1 .. Gm then the
  following functions are defined:

    R_Fk_REF(self) => pointer to the Fk record within self
    R_Fk_G1(self) => value of self.Fk.G1 field
    ..
    R_Fk_Gm(self) => value of self.Fk.Gm field

    R_set_Fk_G1(self, v) => void; set value of self.Fk.G1 field to v
    ..
    R_set_Fk_Gm(self, v) => void; set value of self.Fk.Gm field to v

  These rules are recursive.


Example:

These record definitions:

  @shared struct Point {
    x: float64
    y: float64
  } @end

  @shared struct Sphere {
    r: float64
    c: Point
  } @end

  @shared struct Spheres {
    a: Sphere
    b: Sphere
    m: atomic int32
  } @end

turn into these definitions:

  const Point_SIZE = 8;
  const Point_ALIGN = 8;

  function Point_x(p) { return _mem_i32[(p+0)>>2]; }
  function Point_y(p) { return _mem_i32[(p+4)>>2]; }

  function Point_set_x(p, v) { _mem_i32[(p+0)>>2] = v; }
  function Point_set_y(p, v) { _mem_i32[(p+4)>>2] = v; }

  const Sphere_SIZE = 16;
  const Sphere_ALIGN = 8;

  function Sphere_c_x(p) { return _mem_i32[(p+8)>>2]; }
  function Sphere_c_y(p) { return _mem_i32[(p+12)>>2]; }
  function Sphere_r(p) { return _mem_f64[(p+8)>>3]; }

  function Sphere_set_c_x(p, v) { _mem_i32[(p+8)>>2] = v; }
  function Sphere_set_c_y(p, v) { _mem_i32[(p+12)>>2] = v; }
  function Sphere_set_r(p, v) { _mem_f64[(p+8)>>3] = v; }

  function Sphere_c_REF(p) { return p+8 }

  const Spheres_SIZE = 40;
  const Spheres_ALIGN = 8;

  function Spheres_a_REF { return p }
  function Spheres_b_REF { return p+16 }

  function Spheres_a_c_REF { return p+8 }
  function Spheres_b_c_REF { return p+24 }

  ... etc, lots of methods

  function Spheres_m(p) { return Atomics.load(_mem_i32, 32>>2) }
  function Spheres_set_m(p, v) { Atomics.store(_mem_i32, 32>>2, v) }
  function Spheres_add_m(p, v) { return Atomics.add(_mem_i32, 32>>2, v) }
  ...
  function Spheres_compareExchange_m(p, o, n) { return Atomics.compareExchange(_mem_i32, 32>>2, o, n) }

  
Classes.

A class describes a reference type with mutable fields.

It takes the form of a number of fields followed by a number of
methods.  As for structs, if a field type is a struct type then the
fields of that struct will appear as subfields of the class being
defined.  If a field type is a class type then the value of the field
is a class instance address.

TODO: An object must have an initializer, because there's metadata
to set up.

Syntax:

  Object-def ::= (lookbehind EOL)
                 "@shared" "class" Id ("extends" Id)? "{" Comment? EOL
                 ((Comment | Blank | Field) EOL)*
                 ((Comment | Blank | Method) EOL)*
		 "}" "@end" Comment? EOL

  Method ::= "METHOD" Id "(" "self" ("," Parameter)* ")" "{" Function-body "}"

  Parameter ::= Id (":" Anything-but-comma-or-rightparen+)

  NOTE: The annotation on Parameter is for interop with TypeScript.

Static semantics:

  No cycles in the inheritance graph.

  Uniqueness as for records (objects and records share the same
  namespace).
  
  Base types may be forward declared.

Translation:

  The first field of an object is a hidden int32 field that holds a
  globally invariant type identifier, see below.

  The fields of a supertype are prepended to the fields of the
  subtype, for purposes of layout.
  
  O_SIZE as for records.

  O_ALIGN as for records.

  O_ID for the type ID for the type.

  Field getters/setters are translated as for record.
  
  A method "meth" for object type O with subtypes J and K where J
  overrides meth but K does not (and in this case J could be a subtype
  of K, or not), turns into this global function:

    function O_meth(self, arg, ...) {
        switch (_mem_i32[self>>2]) {
	case J_ID: return J_meth_impl(self, arg, ...); 
	default:   return O_meth_impl(self, arg, ...);
	}
    }

  where the arguments keep their annotations, the annotations on
  O_meth are those of the method defined on O, the others may differ.

Example:

  @shared struct Vec3 {
    x: float64
    y: float64
    z: float64
  } @end

  @shared struct Material {
    diffuse:   Vec3
    specular:  Vec3
    shininess: float64
    ambient:   Vec3
    mirror:    float64
  } @end
  
  @shared class Surface {
    m:Material

    @method intersect(self, a, b, c, d) { throw "Pure" }
    @method normal(self) { throw "Pure" }
  } @end
  
  @shared class Sphere extends Surface {
    center: Vec3
    radius: float64

    @method intersect(self, a, b, c, d) { ... }
    @method normal(self) { ... }
  } @end

  @shared class Triangle extends Surface {
    v1: Vec3
    v2: Vec3
    v3: Vec3

    @method intersect(self, a, b, c, d) { ... }
    @method normal(self) { ... }
  } @end

  @shared class Scene extends Surface {
    objs: array(Surface)

    @method intersect(self, a, b, c, d) { ... }
    @method normal(self) { ... }
  } @end


How to run the translator.

The translator has to be run on all files in the application
simultaneously, and will resolve all types in all files.  It would
normally output a file for each input file.


Type IDs.

Type IDs must be unique and invariant across workers, which are all
running different programs.

A type ID could be the hash value of a string representing the name
and structure of a type.

If a program has two types with the same type ID then the program
cannot be translated.  A fix is likely to change the name of one of
the conflicting types.  If this turns out to be a constant problem we
can introduce a notion of a "brand" on a type which is just a fudge
factor to make the type IDs work out.  (This scales poorly but is
probably OK in practice.)

Eg, O>Triangle>Surface>> is a unique identifier but does not help us
catch errors easily.
