/* -*- mode: javascript -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/*
 * Simple multi-producer and multi-consumer shared-memory queue for
 * transmitting arrays of Int32 values - a useful building block for
 * other mechanisms.
 *
 * This version is built on flatjs.  The original version, in
 * parlib-simple, used hand-built shared-memory data structures.
 *
 * Here an IntQueue has two parts: a local front object in each
 * worker, and a shared representation in shared memory.  The front
 * objects have methods that forward to the methods on shared memory.
 *
 * An IntQueue front object and its shared representation are
 * allocated in a worker using "new".  Then a reference to the shared
 * representation is extracted via the "reference" property, and sent
 * to another worker.  On the other worker, a local front object is
 * created for the shared data using IntQueue.fromReference.
 *
 * It is not necessary to have front objects, but it keeps things
 * cleaner, and when the allocation rate of front objects is low it is
 * not a performance drain.
 *
 * It's almost certain that the front object construction can be
 * placed in a library for reuse.
 */

/*
 * Allocate a new queue in shared memory, and its local front object.
 * "length" is the capacity of the queue in number of integer
 * elements.
 *
 * The _repr argument is for internal use.
 */
function IntQueue(length, _repr) {
    if (typeof length == "number")
	this._repr = IntQueueRepr.init(@new IntQueueRepr, length);
    else
	this._repr = _repr;
}

/*
 * Given a pointer to the shared-memory representation, create a local
 * front object.
 */
IntQueue.fromReference = function (ref) {
    return new IntQueue(IntQueue, ref);
}

/*
 * Retrieve the pointer to the shared-memory representation.
 */
Object.defineProperty(IntQueue.prototype, "reference", { get: function () { return this._repr; } });

/*
 * Enters an element into the queue, waits until space is available or
 * until t milliseconds (undefined == indefinite wait) have passed.
 *
 * ints is a dense Array of Int32 values.
 * Returns true if it succeeded, false if it timed out.
 */
IntQueue.prototype.enqueue = function(ints, t) {
    return IntQueueRepr.enqueue(this._repr, ints, t);
}

/*
 * Returns an element from the queue if there's one, or waits up to t
 * milliseconds (undefined == indefinite wait) for one to appear,
 * returning null if none appears in that time.
 *
 * The element is returned as a dense Array of Int32 values.
 */
IntQueue.prototype.dequeue = function(t) {
    return IntQueueRepr.dequeue(this._repr, t);
}

// Private code below this point

@flatjs class IntQueueRepr {
    spaceAvailable: synchronic int32
    dataAvailable: synchronic int32

    lock: synchronic int32
    head: int32
    tail: int32
    used: int32
    queue: array(int32)
    length: int32;

    @method init(SELF, length) {
	SELF.length = length;
	SELF.queue = @new array(int32, length);
	return SELF;
    }

    @method enqueue(SELF, ints, timeout) {
	var required = ints.length + 1;

	if (!SELF.acquireWithSpaceAvailable(required, t))
	    return false;

	var q = SELF.queue;
	var qlen = SELF.length;
	var tail = SELF.tail;
	int32.array_set(q, tail, ints.length);
	tail = (tail + 1) % qlen;
	for ( var i=0 ; i < ints.length ; i++ ) {
	    int32.array_set(q, tail, ints[i]);
	    tail = (tail + 1) % qlen;
	}
	SELF.tail = tail;
	SELF.used += required;

	SELF.releaseWithDataAvailable();
	return true;
    }

    @method acquireWithSpaceAvailable(SELF, required, t) {
	var limit = typeof t != "undefined" ? Date.now() + t : Number.POSITIVE_INFINITY;
	for (;;) {
	    SELF.acquire();
	    var length = SELF.length;
	    if (length - SELF.used >= required)
		return true;
	    var probe = SELF.spaceAvailable;
	    SELF.release();
	    if (required > length)
		throw new Error("Queue will never accept " + required + " words");
	    var remaining = limit - Date.now();
	    if (remaining <= 0)
		return false;
	    SELF.expectUpdate_spaceAvailable(probe, remaining);
	}
    }

    @method acquireWithDataAvailable(SELF, t) {
	var limit = typeof t != "undefined" ? Date.now() + t : Number.POSITIVE_INFINITY;
	for (;;) {
	    SELF.acquire();
	    if (SELF.used > 0)
		return true;
	    var probe = SELF.dataAvailable;
	    SELF.release();
	    var remaining = limit - Date.now();
	    if (remaining <= 0)
		return false;
	    SELF.expectUpdate_dataAvailable(probe, remaining);
	}
    }

    @method releaseWithSpaceAvailable(SELF) {
	SELF.spaceAvailable += 1;
	SELF.release();
    }

    @method releaseWithDataAvailable(SELF) {
	SELF.dataAvailable += 1;
	SELF.release();
    }

    @method acquire(SELF) {
	while (SELF.compareExchange_lock(0, 1) != 0)
	    SELF.expectUpdate_lock(1, Number.POSITIVE_INFINITY);
    }

    @method release(SELF) {
	SELF.lock = 0;
    }

} @end
