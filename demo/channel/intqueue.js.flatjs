/* -*- mode: javascript -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/*
 * Simple multi-producer and multi-consumer shared-memory queue for
 * transmitting arrays of Int32 values - a useful building block for
 * other mechanisms.
 *
 * This version is built on flatjs.  The original version, in
 * parlib-simple, used hand-built shared-memory data structures.
 */

/*
 * Construct an IntQueue object in any agent.
 *
 * length is the desired capacity of the queue.
 */
function IntQueue(length) {
    this._repr = IntQueueRepr.init(@new IntQueueRepr, length);
}

/*
 * Enters an element into the queue, waits until space is available or
 * until t milliseconds (undefined == indefinite wait) have passed.
 *
 * ints is a dense Array of Int32 values.
 * Returns true if it succeeded, false if it timed out.
 */
IntQueue.prototype.enqueue = function(ints, t) {
    return IntQueueRepr.enqueue(this._repr, ints, t);
}

/*
 * Returns an element from the queue if there's one, or waits up to t
 * milliseconds (undefined == indefinite wait) for one to appear,
 * returning null if none appears in that time.
 *
 * The element is returned as a dense Array of Int32 values.
 */
IntQueue.prototype.dequeue = function(t) {
    return IntQueueRepr.dequeue(this._repr, t);
}

// Private code below this point

@flatjs class IntQueueRepr {
    spaceAvailable: synchronic int32
    dataAvailable: synchronic int32

    lock: synchronic int32
    head: int32
    tail: int32
    used: int32
    queue: array(int32)
    length: int32;

    @method init(SELF, length) {
	SELF.length = length;
	SELF.queue = @new array(int32, length);
	return SELF;
    }

    // None of these are virtual and we should not pay for vcall overhead.
    // But can that be optimized out (under what assumptions?) or should
    // there be annotations?

    @method enqueue(SELF, ints, timeout) {
	var required = ints.length + 1;

	if (!SELF.acquireWithSpaceAvailable(required, t))
	    return false;

	var q = SELF.queue;
	var qlen = SELF.length;
	var tail = SELF.tail;
	int32.array_set(q, tail, ints.length);
	tail = (tail + 1) % qlen;
	for ( var i=0 ; i < ints.length ; i++ ) {
	    int32.array_set(q, tail, ints[i]);
	    tail = (tail + 1) % qlen;
	}
	SELF.tail = tail;
	SELF.used += required;

	SELF.releaseWithDataAvailable();
	return true;
    }

    @method acquireWithSpaceAvailable(SELF, required, t) {
	var limit = typeof t != "undefined" ? Date.now() + t : Number.POSITIVE_INFINITY;
	for (;;) {
	    SELF.acquire();
	    var length = SELF.length;
	    if (length - SELF.used >= required)
		return true;
	    var probe = SELF.spaceAvailable;
	    SELF.release();
	    if (required > length)
		throw new Error("Queue will never accept " + required + " words");
	    var remaining = limit - Date.now();
	    if (remaining <= 0)
		return false;
	    SELF.expectUpdate_spaceAvailable(probe, remaining);
	}
    }

    @method acquireWithDataAvailable(SELF, t) {
	var limit = typeof t != "undefined" ? Date.now() + t : Number.POSITIVE_INFINITY;
	for (;;) {
	    SELF.acquire();
	    if (SELF.used > 0)
		return true;
	    var probe = SELF.dataAvailable;
	    SELF.release();
	    var remaining = limit - Date.now();
	    if (remaining <= 0)
		return false;
	    SELF.expectUpdate_dataAvailable(probe, remaining);
	}
    }

    @method releaseWithSpaceAvailable(SELF) {
	SELF.spaceAvailable += 1;
	SELF.release();
    }

    @method releaseWithDataAvailable(SELF) {
	SELF.dataAvailable += 1;
	this.release();
    }

    @method acquire(SELF) {
	while (SELF.compareExchange_lock(0, 1) != 0)
	    SELF.expectUpdate_lock(1, Number.POSITIVE_INFINITY);
    }

    @method release(SELF) {
	SELF.lock = 0;
    }

} @end
