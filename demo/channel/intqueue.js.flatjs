/* -*- mode: javascript -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/*
 * Simple multi-producer and multi-consumer shared-memory queue for
 * transmitting arrays of Int32 values - a useful building block for
 * other mechanisms.
 *
 * This version is built on flatjs.  The original version, in
 * parlib-simple, used hand-built shared-memory data structures.
 */

// NOTE: There is a lesson here, which is that for some kinds of data
// structures, it would be nice to generate JS code to act as front
// objects.  IntQueue is a case in point.
//
// We need a three-pronged API:
//  - new IntQueue(length) => IQ
//  - IQ.reference => pointer
//  - IntQueue.fromReference(pointer) => IQ
//
// Use the first one in any worker, then send the pointer and
// reconstitute it in any other worker.
//
// Or, don't bother with the front object, just expose the fact that
// the IntQueue is in shared memory and require shared-memory syntax
// to use it.

function FrontObject(constructorName, reprType, methods) {
    // ???
    var actual = function () {}
    var constructor = function (...args) {
	var p = reprType.initInstance(FlatJS.allocOrThrow(reprType.SIZE, reprType.ALIGN));
	this._repr = reprType.init ? reprType.init(p, ...args) : p;
    }
    constructor.name = constructorName;
    for ( var [name,arity] of methods ) {
	constructor.prototype.name = function (...args) {
	    reprType[name].(this._repr, ...args);
	}
    }
    constructor.fromReference = function (p) {}
    return constructor;
}

var IntQueue = FrontObject("IntQueue", 1, IntQueueRepr, [["enqueue",2], ["dequeue",2]]);
//                         constructor    repr type       method/arity ...

// FIXME!

/*
 * Enters an element into the queue, waits until space is available or
 * until t milliseconds (undefined == indefinite wait) have passed.
 *
 * ints is a dense Array of Int32 values.
 * Returns true if it succeeded, false if it timed out.
 */
// IntQueue.prototype.enqueue = function(ints, t) {
//     return IntQueueRepr.enqueue(this._repr, ints, t);
// }

/*
 * Returns an element from the queue if there's one, or waits up to t
 * milliseconds (undefined == indefinite wait) for one to appear,
 * returning null if none appears in that time.
 *
 * The element is returned as a dense Array of Int32 values.
 */
// IntQueue.prototype.dequeue = function(t) {
//     return IntQueueRepr.dequeue(this._repr, t);
// }

// Private code below this point

@flatjs class IntQueueRepr {
    spaceAvailable: synchronic int32
    dataAvailable: synchronic int32

    lock: synchronic int32
    head: int32
    tail: int32
    used: int32
    queue: array(int32)
    length: int32;

    // Note, this is wrong except in the first worker that uses it.

    @method init(SELF, length) {
	SELF.length = length;
	SELF.queue = @new array(int32, length);
	return SELF;
    }

    // None of these are virtual and we should not pay for vcall overhead.
    // But can that be optimized out (under what assumptions?) or should
    // there be annotations?

    @method enqueue(SELF, ints, timeout) {
	var required = ints.length + 1;

	if (!SELF.acquireWithSpaceAvailable(required, t))
	    return false;

	var q = SELF.queue;
	var qlen = SELF.length;
	var tail = SELF.tail;
	int32.array_set(q, tail, ints.length);
	tail = (tail + 1) % qlen;
	for ( var i=0 ; i < ints.length ; i++ ) {
	    int32.array_set(q, tail, ints[i]);
	    tail = (tail + 1) % qlen;
	}
	SELF.tail = tail;
	SELF.used += required;

	SELF.releaseWithDataAvailable();
	return true;
    }

    @method acquireWithSpaceAvailable(SELF, required, t) {
	var limit = typeof t != "undefined" ? Date.now() + t : Number.POSITIVE_INFINITY;
	for (;;) {
	    SELF.acquire();
	    var length = SELF.length;
	    if (length - SELF.used >= required)
		return true;
	    var probe = SELF.spaceAvailable;
	    SELF.release();
	    if (required > length)
		throw new Error("Queue will never accept " + required + " words");
	    var remaining = limit - Date.now();
	    if (remaining <= 0)
		return false;
	    SELF.expectUpdate_spaceAvailable(probe, remaining);
	}
    }

    @method acquireWithDataAvailable(SELF, t) {
	var limit = typeof t != "undefined" ? Date.now() + t : Number.POSITIVE_INFINITY;
	for (;;) {
	    SELF.acquire();
	    if (SELF.used > 0)
		return true;
	    var probe = SELF.dataAvailable;
	    SELF.release();
	    var remaining = limit - Date.now();
	    if (remaining <= 0)
		return false;
	    SELF.expectUpdate_dataAvailable(probe, remaining);
	}
    }

    @method releaseWithSpaceAvailable(SELF) {
	SELF.spaceAvailable += 1;
	SELF.release();
    }

    @method releaseWithDataAvailable(SELF) {
	SELF.dataAvailable += 1;
	this.release();
    }

    @method acquire(SELF) {
	while (SELF.compareExchange_lock(0, 1) != 0)
	    SELF.expectUpdate_lock(1, Number.POSITIVE_INFINITY);
    }

    @method release(SELF) {
	SELF.lock = 0;
    }

} @end
